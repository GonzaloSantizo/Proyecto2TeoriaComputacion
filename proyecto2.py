def cyk_parse(grammar, sentence):
    n = len(sentence)
    num_nonterminals = len(grammar)
    
    # Initialize a table to store parsing results
    table = [[set() for _ in range(n)] for _ in range(n)]
    
    # Fill in the diagonal of the table based on terminal symbols
    for i in range(n):
        for nonterminal, productions in grammar.items():
            for production in productions:
                if production == sentence[i]:
                    table[i][i].add(nonterminal)
    
    # Fill in the table based on CFG rules
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            for k in range(i, j):
                for nonterminal, productions in grammar.items():
                    for production in productions:
                        if len(production) == 2 and production[0] in table[i][k] and production[1] in table[k + 1][j]:
                            table[i][j].add(nonterminal)
    
    # If the start symbol is in the top-right cell of the table, the sentence is in the language
    return 'S' in table[0][n - 1]

# Modified grammar
grammar = {
    'S': ['NP VP'],
    'VP': ['VP PP', 'V NP', 'cooks', 'drinks', 'eats', 'cuts'],
    'PP': ['P NP'],
    'NP': ['Det N', 'he', 'she'],
    'V': ['cooks', 'drinks', 'eats', 'cuts'],
    'P': ['in', 'with'],
    'N': ['cat', 'dog', 'beer', 'cake', 'juice', 'meat', 'spoon', 'fork', 'knife', 'oven'],
    'Det': ['a', 'the']
}

sentence = ['the', 'cat', 'eats', 'a', 'cake']
result = cyk_parse(grammar, sentence)
if result:
    print("The sentence can be generated by the grammar.")
else:
    print("The sentence cannot be generated by the grammar.")
